<!DOCTYPE html>
<html lang="en" >

<head>
   <meta charset="UTF-8" />
   <link rel="stylesheet" href="mystyle.css" />
   <link rel="stylesheet" href="fontscss2.css" />
</head>

<body>

<h1 id="main-heading" >Hi there! Welcome to my page.</h1>
<img src="http://placebear.com/250/300" align="right" alt="bears">

<p> This is <b> Deepanshu Aggarwal </b>, currently a Ph.D. student in the physics department at the <a href="https://www.iitd.ac.in"> Institute of Technology Delhi </a>, India. </p>

<div id="rectangle">
<h2 id="second-heading">List of publications:</h2>
<ol>
<li> <b> D. Aggarwal </b>, R. Narula, and S. Ghosh, “Moir&eacute; fractals in twisted graphene layers”,
   <a href="https://doi.org/10.1103/PhysRevB.109.125302"> Phys. Rev. B <b> 109 </b>, 125302 (2024) </a> </li>
<li> <b> D. Aggarwal </b>, R. Narula, and S. Ghosh, “A primer on twistronics: a massless dirac fermion&prime;s journey to moir´ e patterns and flat bands in twisted bilayer graphene”,<a
href="https://doi.org/10.1088/1361-648X/acb984"> Journal of Physics: Condensed Matter <b> 35 </b>, 143001 (2023) </a> </li>
<li> D. Arora, <b> D. Aggarwal </b>, S. Ghosh, and R. Narula, Photon absorption in twisted bilayer graphene,<a href=""> 2023 </a> </li>
<li> D. Arora, <b> D. Aggarwal </b>, S. Ghosh, and R. Narula, “Interference effects in polarizationcontrolled rayleigh scattering in twisted bilayer graphene”,
   <a href="https://doi.org/10.1103/PhysRevB.107.205423"> Phys. Rev. B <b> 107 </b>, 205423 (2023) </a> </li>
</ol>
</div>

<h2 id="heading3"> Brief description of research works: </h2>
<ul>
   <li>
      <div id="rectangle">
      <p> Here, I elaborate on my Ph.D. research projects that mostly focussed on twisted bilayer graphene (tBLG) and other supermoir&eacute; structures.
   For example, the topical review [<a href="https://doi.org/10.1088/1361-648X/acb984"> Journal of Physics: Condensed Matter <b> 35 </b>, 143001 (2023) </a>]
   starts from the details of a massless Dirac fermion in various superlattice potentials that causes the appearance of the clones of such
   Dirac points in the energy spectrum. Further, we reviewed the moir&eacute; patterns in graphene over hexagonal Boron nitride (hBN) and
   tBLG and showed the details of various effective continuum models like the Bistritzer and MacDonald model and its special case of
   chiral symmetric Hamiltonian. At the end, we also provided a number of important theoretical and experimental works in tBLG and
   some other systems like twisted double bilayer graphene, twisted trilayer graphene etc. In the process of writing this review,
   I exhaustively covered a significant literature survey in twistronics while working out each and every detail. </p>
</div>
</li>
<video controls width="800" height="600" align="center" autoplay muted>
   <source src="videos/revPromoVidFinal.mp4" type="video/mp4">
</video>

<li> <p> Alongside this review, we thought about the problem of a moir&eacute; system such as a tBLG in the presence of such a superlattice
   potential having same moir&eacute; periodicity and then we came up with the idea of the ”moir&eacute; fractals in twisted graphene layers”
   [<a href="https://doi.org/10.1103/PhysRevB.109.125302"> Phys. Rev. B <b> 109 </b>, 125302 (2024) </a>]. The fractals like
   hierarchy emerge when a tBLG is subjected to a sequence of such moir&eacute; periodic potentials and we dubbed them as moir&eacute; fractals.
   For this, we studied a number of papers on fractals to analytically obtain various affine mappings that gave the required fractal
   generator of a commensurate supermoir&eacute; pattern. In order to get the meaning to an expression in this work, we also studied
   various papers in a very different field of economical geography and implemented them to bring out an interesting connection
   between the arrangement of central places in Central Place theory and the hexagonal structure of commensurate supermoir&eacute; systems.
   We also did the literature survey of various supermoir&eacute; systems in order to show that the effective continuum model of such
   systems can be written as the model Hamiltonian of moir&eacute; fractals and a periodic perturbation.
</p>
</li>

<p> In collaboration with another Ph.D. student in the same group, we investigated the optical properties of tBLG and compared them
   to its perfectly aligned counterpart and single layer graphene. Here, I contributed to develop various codes to calculate the
   relevant band structures and the optical matrix elements. Out of the two works, one is published
   [<a href="https://doi.org/10.1103/PhysRevB.107.205423"> Phys. Rev. B <b> 107 </b>, 205423 (2023) </a>], and the other is available
   as a preprint [D. Arora, D. Aggarwal, S. Ghosh, and R. Narula, Photon absorption in twisted bilayer graphene, 2023].
</p>

<p> Now, since the lattice relaxations are necessary to include in the effective continuum models to get an accurate low-energy description
   of a moir&eacute; systems like tBLG, therefore we are extending the idea of the moir&eacute; fractals by investigating the effects of lattice
   relaxation-induced strain field on moir&eacute; fractals. During my preliminary training before delving into the actual research problems,
   I have developed strong analytical skills such as
<ul>
<li> <i> Single-particle studies </i>: I reproduced many single-particle results for a massless Dirac fermion in different superlattice
   potentials. I studied different moir&eacute; systems such tBLG, twisted double bilayer graphene, transition metal dichalcogenides etc where
   I calculated the band structures and related properties like density of states, probability densities etc. Some of these results are
   already published in the topical review. </li>
<li> <i> Many-body techniques </i>: In the many-body techniques, I calculated the zero- and finite temperature Green&prime;s functions
   for single and bilayer graphene to obtain correlation functions such as densitydensity correlation function and further
   calculated the vacuum polarization as a function of the transfer wave vector q frequency &omega;. </li>
<li> <i> Computational work </i>: To obtain the band structures and the dependent properties such as density of states,
   probability density. I learned to write the codes from scratch using languages like Python, Matlab, and Wolfram Mathematica. </li>
</ul>
</ul>

<p>And code highlighting:</p>
<pre><code 
import math
import numpy as np
from numpy import typing
from scipy import linalg as la, integrate, special
from scipy.spatial.transform import Rotation
from unittest import TestCase

# Tolerance for floats
TOL = 1e-8

# Defining a test object from TestCase class of unittest
test = TestCase()

## Defining various types for declaring arguments type or annotations
num = float|int # A number that can be a float or an int
ndarrd = typing.NDArray[np.int_|np.double] # A numpy ndarray with dtype=np.double
ndarrc = typing.NDArray[np.cdouble] # A numpy ndarray with dtype=np.double

##***** GENERAL FUNCTIONS *****

# Function (rotMat2dz) that generates a 2D rotation matrix about z-axis
def rotMat2dz(theta: num) -> ndarrd:
    """
    This function generates a 2D rotaton matrix about z-axis.
    Note: theta is in radians and is considered positive counterclockwise.
    """
    rotClass = Rotation.from_euler('z', theta, degrees=False)
    rotz2d = rotClass.as_matrix()[0:2,0:2]
    # returning the 2D rotation matrix about z-axis
    return rotz2d
#----------rotMat2dz-----------

# Function (rot2dz)
def rot2dz(theta: num|ndarrd, pointrot: ndarrd|list[num]|tuple[num, num],
           pointabt: ndarrd|list[num]|tuple[num, num] = (0,0)) -> ndarrd:
    """
    Rotates one (or more) 2D-vector(s) with one (or more) angle(s) about a point (x0,y0).

    params:
    ---
    theta : float| int | np.ndarray -- Angle(s) of rotation
    pointrot : tuple| list | np.ndarray -- vector(s) that has to be rotated
    pointabt : tuple | list | np.ndarray -- point of rotation
    """
    # converting into numpy arrays
    theta = np.asarray_chkfinite(theta); pointrot = np.asarray_chkfinite(pointrot)
    pointabt = np.asarray_chkfinite(pointabt)

    # defining new vectors w.r.t pointabt
    if pointrot.ndim == 1: # a 1D-array
        vecnew = np.hstack((pointrot - pointabt,0)) # A 1D-array with z-axis
    elif pointrot.ndim == 2: # a 2D-array
        vecnew = np.hstack((pointrot - pointabt, np.zeros((pointrot.shape[0],1))))
    else:
        raise ValueError("The no. of dimensions in pointrot is more than 2!")
    
    # Generating the rotation matrices for different angles in theta-array
    rotzClass = Rotation.from_euler('z', theta, degrees=False)
    # It may be only one 3*3 matrix or a set of 3*3 matrices equal to the number of elements in theta-array

    # Finding the number of dimensions in vecnew
    if vecnew.ndim == 1:
        vecnewRot = rotzClass.apply(vecnew)
        # Checking for norm equality
        if vecnewRot.ndim == 1:
            chknorm = np.abs(np.subtract(la.norm(vecnewRot),la.norm(vecnew))) < TOL
        else:
            chknorm = np.all(np.subtract(la.norm(vecnewRot,axis=1), la.norm(vecnew)) < TOL)
    else:
        if theta.size == 1: # it means there is only one 3*3 matrix in rotzClass
            vecnewRot = rotzClass.apply(vecnew)
            # Checking for norm equality
            chknorm = np.all(np.subtract(la.norm(vecnewRot,axis=1), la.norm(vecnew)) < TOL)
        else:
            raise NotImplementedError("Multiple vectors with multiple rotation is not implemented!")
    
    # testing for norm
    test.assertTrue(chknorm, msg="The norm of rotated and unrotated vecs are not same!")

    # Returning the array 'vecnewRot'
    if vecnewRot.ndim == 1:
        return vecnewRot[0:2]
    else:
        return vecnewRot[:,0:2]
#-----------rot2dz--------------

# Function for getting the real-space primitive lattice vectors
def realVec(lattConst: num, phi: num, theta: num = 0) -> tuple[ndarrd, ndarrd]:
    """
    Calculates the real-space primitive lattice vectors with lattice constant 'a'
    and angle 'phi' between a1 and a2.
    """
    # Direct-lattice primitive vectors (due to active rotation 'theta')
    a1 = rot2dz(theta, lattConst*np.array([1,0]))
    a2 = rot2dz(theta, lattConst*np.array([math.cos(phi), math.sin(phi)]))

    # Norm of input vectors
    isanormsame = abs(la.norm(a1) - la.norm(a2)) < TOL
    test.assertTrue(isanormsame, msg="The vectors a1 and a2 do not have equal norm!")

    # returning the vectors
    return (a1, a2)

# Function (recVec) - generates the reciprocal lattice vectors
def recVec(a1: ndarrd|list[num]|tuple[num, num], 
           a2: ndarrd|list[num]|tuple[num, num]) -> tuple[ndarrd, ndarrd]:
    """
    Calculates the reciprocal lattice vectors corresponding to the given vectors a1 and a2.

    params:
    ---
    a1 : 2-tuple | list | 1D numpy array
    a2 : 2-tuple | list | 1D numpy array

    return:
    ---
    A 2-tuple (b1,b2) of reciprocal lattice vectors.
    """
    # Converting a1 and a2 into numpy arrays
    a1 = np.asarray_chkfinite(a1); a2 = np.asarray_chkfinite(a2)

    # creating a matrix [a1,a2] of the primitive lattice vectors
    realMat = np.column_stack((a1,a2))
    
    # finding the reciprocal space lattice vectors
    # Note: la.inv raises LinAlgErr if realMat is singular. 
    reciMat = np.transpose((2*math.pi)*la.inv(realMat))
    
    # The reciprocal lattice vectors
    b1 = reciMat[:,0].copy(); b2 = reciMat[:,1].copy()

    # test-1 (Laue Conditions) for reciprocal lattice vectors
    chkLaue1 = np.logical_and(np.dot(a1,b2) < TOL, np.dot(a2,b1) < TOL)
    chkLaue2 = np.logical_and(abs(np.dot(a1,b1) - 2*math.pi) < TOL,
                              abs(np.dot(a2,b2) - 2*math.pi) < TOL)
    test.assertTrue(chkLaue1 or chkLaue2,
                    msg="The reciprocal lattice vectors are violating Laue condiitons!")

    # test-2 (Product of area should be (2*pi)**2
    Areal = abs(la.det(realMat)); Areci = abs(la.det(reciMat))
    test.assertTrue(abs(Areal*Areci - (2*np.pi)**2) < TOL, msg="The area test is failed!")

    # test-3 (Equal Norm test)
    isbrnormsame = abs(la.norm(b1) - la.norm(b2)) < TOL
    test.assertTrue(isbrnormsame, msg="The vectors b1 and b2 do not have equal norm!")

    # Returning the vectors b1 and b2
    return (b1,b2)
#--------------recVec----------------
</code></pre>
<p>Or inline code like <code>var foo = &#39;bar&#39;;</code>.</p>
<p>Or an image of bears</p>
<p>The end ...</p>

</body>
</html>
